var bip38 = (function() {
    var scrypt = scrypt_module_factory();
    var rng = new SecureRandom();

    return {
        encrypt: function(input, salt_a) {
            if (!salt_a) {
                salt_a = Bitcoin.ECDSA.getBigRandom(new BigInteger('FFFFFFFF', 16), rng).toByteArrayUnsigned();
                while (salt_a.length < 4) { salt_a.unshift(0); }
            }
            salt = new Uint8Array(salt_a);

            var key = scrypt.crypto_scrypt(scrypt.encode_utf8(input.key),
                                           salt, 16384, 8, 8, 64);
            var derivedhalf1 = key.subarray(0, 32), derivedhalf2 = key.subarray(32, 64);
            var message = [];
            for (var i = 0; i < 32; i++) {
                message.push(input.data[i] ^ derivedhalf1[i]);
            }

            C.AES._init(derivedhalf2);
            (new C.mode.ECB({
                    pad : function (cipher,message) {},
                    unpad : function (cipher,message) {}
                })).encrypt(C.AES, message, []);

            return message.concat(salt_a);
        },
        decrypt: function(input) {
            cur_coin_version = input.cur_coin_version;
            var bytes = B58.decode(input.data);
            if (bytes.length != 43) {
                return {error: 'invalid_privkey'}
            }
            var expChecksum = bytes.slice(-4);
            bytes = bytes.slice(0, -4);
            var checksum = Crypto.SHA256(Crypto.SHA256(bytes, {asBytes: true}), {asBytes: true});
            if (checksum[0] != expChecksum[0] || checksum[1] != expChecksum[1] || checksum[2] != expChecksum[2] || checksum[3] != expChecksum[3]) {
                return {error: 'invalid_privkey'};
            }

            var salt = bytes.slice(3, 7);
            var derivedBytes = scrypt.crypto_scrypt(scrypt.encode_utf8(input.key),
                                           salt, 16384, 8, 8, 64);

            C.AES._init(derivedBytes.subarray(32, 32+32));
            var decrypted = bytes.slice(7, 7+32);
            (new C.mode.ECB({
                    pad : function (cipher,message) {},
                    unpad : function (cipher,message) {}
                })).decrypt(C.AES, decrypted, []);

            for (var x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];
            var tmpkey = new Bitcoin.ECKey(decrypted);
            if (bytes[2] & 0x20) {  // compressed
                var base58AddrText = tmpkey.getBitcoinAddressCompressed().toString();
            } else {
                var base58AddrText = tmpkey.getBitcoinAddress().toString();
            }
            var checksum = Crypto.SHA256(Crypto.SHA256(base58AddrText, {asBytes: true}), {asBytes: true});
            if (checksum[0] != bytes[3] || checksum[1] != bytes[4] || checksum[2] != bytes[5] || checksum[3] != bytes[6]) {
                return {error: 'invalid_passphrase'};
            }

            return decrypted;
        }

    };
})();
