var bip38 = (function() {
    var scrypt = scrypt_module_factory();

    return {
        encrypt: function(input, salt_a) {
            if (!salt_a) {
                salt_a = Bitcoin.ecdsa.getBigRandom(new Bitcoin.BigInteger('FFFFFFFF', 16)).toByteArrayUnsigned();
                while (salt_a.length < 4) { salt_a.unshift(0); }
            }
            salt = new Uint8Array(salt_a);

            var key = scrypt.crypto_scrypt(scrypt.encode_utf8(input.key),
                                           salt, 16384, 8, 8, 64);
            var derivedhalf1 = key.subarray(0, 32), derivedhalf2 = key.subarray(32, 64);
            var message = [];
            for (var i = 0; i < 32; i++) {
                message.push(input.data[i] ^ derivedhalf1[i]);
            }

            var message = Bitcoin.convert.wordArrayToBytes(
                Bitcoin.CryptoJS.AES.encrypt(
                    Bitcoin.convert.bytesToWordArray(message),
                    Bitcoin.convert.bytesToWordArray(derivedhalf2),
                    {mode: Bitcoin.CryptoJS.mode.ECB,
                     padding: Bitcoin.CryptoJS.pad.NoPadding}).ciphertext);

            return message.concat(salt_a);
        },
        decrypt: function(input) {
            cur_coin_version = input.cur_coin_version;
            var bytes = Bitcoin.base58.decode(input.data);
            if (bytes.length != 43) {
                return {error: 'invalid_privkey'}
            }
            var expChecksum = bytes.slice(-4);
            bytes = bytes.slice(0, -4);
            var words = Bitcoin.convert.bytesToWordArray(bytes);
            var checksum = Bitcoin.CryptoJS.SHA256(Bitcoin.CryptoJS.SHA256(words));
            checksum = Bitcoin.convert.wordArrayToBytes(checksum);
            if (checksum[0] != expChecksum[0] || checksum[1] != expChecksum[1] || checksum[2] != expChecksum[2] || checksum[3] != expChecksum[3]) {
                return {error: 'invalid_privkey'};
            }

            var salt = bytes.slice(3, 7);
            var derivedBytes = scrypt.crypto_scrypt(scrypt.encode_utf8(input.key),
                                           salt, 16384, 8, 8, 64);

            /*C.AES._init();
            (new C.mode.ECB({
                    pad : function (cipher,message) {},
                    unpad : function (cipher,message) {}
                })).decrypt(C.AES, decrypted, []);*/

            var encrypted = Bitcoin.convert.bytesToWordArray(bytes.slice(7, 7+32));
            var decrypted = Bitcoin.convert.wordArrayToBytes(
                Bitcoin.CryptoJS.AES.decrypt(
                    Bitcoin.CryptoJS.lib.CipherParams.create({ciphertext: encrypted}),
                    Bitcoin.convert.bytesToWordArray(derivedBytes.subarray(32, 32+32)),
                    {mode: Bitcoin.CryptoJS.mode.ECB,
                     padding: Bitcoin.CryptoJS.pad.NoPadding}));

            for (var x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];
            var compressed = bytes[2] & 0x20;
            var tmpkey = new Bitcoin.ECKey(decrypted, compressed);
            var base58AddrText = tmpkey.getAddress(cur_coin_version).toString();

            var checksum = Bitcoin.CryptoJS.SHA256(Bitcoin.CryptoJS.SHA256(base58AddrText));
            checksum = Bitcoin.convert.wordArrayToBytes(checksum);
            if (checksum[0] != bytes[3] || checksum[1] != bytes[4] || checksum[2] != bytes[5] || checksum[3] != bytes[6]) {
                return {error: 'invalid_passphrase'};
            }

            return decrypted;
        }

    };
})();
